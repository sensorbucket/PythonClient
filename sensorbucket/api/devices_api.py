# coding: utf-8
# # This template file is fetched from openapi-generator and modified
# # Run `openapi-generator-cli author template -g python-nextgen -o outputfolder`
# # to get all template files, make the required modifications. If a template is 
# # missing it will fallback to the default template.

"""
    Sensorbucket API

    SensorBucket processes data from different sources and devices into a single standardized format.  An applications connected to SensorBucket, can use all devices SensorBucket supports.  Missing a device or source? SensorBucket is designed to be scalable and extendable. Create your own worker that receives data from an AMQP source, process said data and output in the expected worker output format.  Find out more at: https://developer.sensorbucket.nl/  Developed and designed by Provincie Zeeland and Pollex   # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: info@pollex.nl
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings
import urllib

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated
from typing import Generator 

from pydantic import Field, StrictFloat, StrictInt, StrictStr

from typing import Optional, Union

from sensorbucket.models.create_device201_response import CreateDevice201Response
from sensorbucket.models.create_device_request import CreateDeviceRequest
from sensorbucket.models.create_device_sensor201_response import CreateDeviceSensor201Response
from sensorbucket.models.create_sensor_request import CreateSensorRequest
from sensorbucket.models.delete_device_sensor200_response import DeleteDeviceSensor200Response
from sensorbucket.models.get_device200_response import GetDevice200Response
from sensorbucket.models.list_device_sensors200_response import ListDeviceSensors200Response
from sensorbucket.models.list_devices200_response import ListDevices200Response
from sensorbucket.models.update_device200_response import UpdateDevice200Response
from sensorbucket.models.update_device_request import UpdateDeviceRequest

from sensorbucket.api_client import ApiClient
from sensorbucket.api_response import ApiResponse
from sensorbucket.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)

class DevicesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    

    @validate_arguments
    def create_device(self, create_device_request : Optional[CreateDeviceRequest] = None, **kwargs) -> CreateDevice201Response:  # noqa: E501
        """Create device  # noqa: E501

        Create a new device.  Depending on the type of device and the network it is registered on. The device might need specific properties to be set.   **For example:** A LoRaWAN device often requires a `dev_eui` property to be set. The system will match incoming traffic against that property.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device(create_device_request, async_req=True)
        >>> result = thread.get()

        :param create_device_request:
        :type create_device_request: CreateDeviceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateDevice201Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_device_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_device_with_http_info(create_device_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_device_with_http_info(self, create_device_request : Optional[CreateDeviceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create device  # noqa: E501

        Create a new device.  Depending on the type of device and the network it is registered on. The device might need specific properties to be set.   **For example:** A LoRaWAN device often requires a `dev_eui` property to be set. The system will match incoming traffic against that property.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device_with_http_info(create_device_request, async_req=True)
        >>> result = thread.get()

        :param create_device_request:
        :type create_device_request: CreateDeviceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateDevice201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_device_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_device_request'] is not None:
            _body_params = _params['create_device_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "CreateDevice201Response",
            '401': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/devices', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    

    @validate_arguments
    def create_device_sensor(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], create_sensor_request : Optional[CreateSensorRequest] = None, **kwargs) -> CreateDeviceSensor201Response:  # noqa: E501
        """Create sensor for device  # noqa: E501

        Create a new sensor for the device with the given identifier.  A device can not have sensors with either a duplicate `code` or duplicate `external_id` field. As this would result in conflicts while matching incoming messages to devices and sensors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device_sensor(device_id, create_sensor_request, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param create_sensor_request:
        :type create_sensor_request: CreateSensorRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateDeviceSensor201Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_device_sensor_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_device_sensor_with_http_info(device_id, create_sensor_request, **kwargs)  # noqa: E501

    @validate_arguments
    def create_device_sensor_with_http_info(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], create_sensor_request : Optional[CreateSensorRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create sensor for device  # noqa: E501

        Create a new sensor for the device with the given identifier.  A device can not have sensors with either a duplicate `code` or duplicate `external_id` field. As this would result in conflicts while matching incoming messages to devices and sensors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_device_sensor_with_http_info(device_id, create_sensor_request, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param create_sensor_request:
        :type create_sensor_request: CreateSensorRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateDeviceSensor201Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'device_id',
            'create_sensor_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_device_sensor" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['device_id']:
            _path_params['device_id'] = _params['device_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_sensor_request'] is not None:
            _body_params = _params['create_sensor_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '201': "CreateDeviceSensor201Response",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/devices/{device_id}/sensors', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    

    @validate_arguments
    def delete_device_sensor(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], sensor_code : Annotated[StrictStr, Field(..., description="The code of the sensor")], **kwargs) -> DeleteDeviceSensor200Response:  # noqa: E501
        """Delete sensor  # noqa: E501

        Delete a sensor from the system.   Since a sensor can only be related to one and only one device at a time, the sensor will be deleted from the system completely   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_device_sensor(device_id, sensor_code, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param sensor_code: The code of the sensor (required)
        :type sensor_code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeleteDeviceSensor200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the delete_device_sensor_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.delete_device_sensor_with_http_info(device_id, sensor_code, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_device_sensor_with_http_info(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], sensor_code : Annotated[StrictStr, Field(..., description="The code of the sensor")], **kwargs) -> ApiResponse:  # noqa: E501
        """Delete sensor  # noqa: E501

        Delete a sensor from the system.   Since a sensor can only be related to one and only one device at a time, the sensor will be deleted from the system completely   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_device_sensor_with_http_info(device_id, sensor_code, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param sensor_code: The code of the sensor (required)
        :type sensor_code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeleteDeviceSensor200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'device_id',
            'sensor_code'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_device_sensor" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['device_id']:
            _path_params['device_id'] = _params['device_id']

        if _params['sensor_code']:
            _path_params['sensor_code'] = _params['sensor_code']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "DeleteDeviceSensor200Response",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/device/{device_id}/sensors/{sensor_code}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    

    @validate_arguments
    def get_device(self, id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The numeric ID of the device")], **kwargs) -> GetDevice200Response:  # noqa: E501
        """Get device  # noqa: E501

        Get the device with the given identifier.  The returned device will also include the full model of the sensors attached to that device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_device(id, async_req=True)
        >>> result = thread.get()

        :param id: The numeric ID of the device (required)
        :type id: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetDevice200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_device_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_device_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_device_with_http_info(self, id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The numeric ID of the device")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get device  # noqa: E501

        Get the device with the given identifier.  The returned device will also include the full model of the sensors attached to that device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_device_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The numeric ID of the device (required)
        :type id: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetDevice200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "GetDevice200Response",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/devices/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    
    @validate_arguments
    def list_device_sensors_gen(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> Generator[ListDeviceSensors200Response, None, None]:  # noqa: E501
        """List sensors device  # noqa: E501
        This method wraps the API pagination logic and returns an generator which at each iteration fetches a new page.

        List all sensors related to the device with the provided identifier   # noqa: E501

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :rtype: Generator[ListDeviceSensors200Response]
        """
        result = self.list_device_sensors(device_id=device_id,cursor=cursor,limit=limit,)
        yield result
        while result.links.next != "":
            cursor = urllib.parse.parse_qs(urllib.parse.urlparse(result.links.next).query)['cursor'][0]
            result = self.list_device_sensors(device_id = device_id,cursor = cursor,limit = limit,)
            yield result

    @validate_arguments
    def list_device_sensors(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ListDeviceSensors200Response:  # noqa: E501
        """List sensors device  # noqa: E501

        List all sensors related to the device with the provided identifier   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_device_sensors(device_id, cursor, limit, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDeviceSensors200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_device_sensors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_device_sensors_with_http_info(device_id, cursor, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def list_device_sensors_with_http_info(self, device_id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The identifier of the device")], cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List sensors device  # noqa: E501

        List all sensors related to the device with the provided identifier   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_device_sensors_with_http_info(device_id, cursor, limit, async_req=True)
        >>> result = thread.get()

        :param device_id: The identifier of the device (required)
        :type device_id: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDeviceSensors200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'device_id',
            'cursor',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_device_sensors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['device_id']:
            _path_params['device_id'] = _params['device_id']


        # process the query parameters
        _query_params = []
        if _params.get('cursor') is not None:  # noqa: E501
            _query_params.append(('cursor', _params['cursor']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDeviceSensors200Response",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/devices/{device_id}/sensors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    
    @validate_arguments
    def list_devices_gen(self, properties : Annotated[Optional[StrictStr], Field(description="Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped")] = None, north : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, west : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, east : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, south : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, latitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, longitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, distance : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point.  The distance is given in meters. ")] = None, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> Generator[ListDevices200Response, None, None]:  # noqa: E501
        """List devices  # noqa: E501
        This method wraps the API pagination logic and returns an generator which at each iteration fetches a new page.

        Fetch a list of devices.  Devices can be filtered on three items: properties, distance from a location or a bounding box.  - Filtering on properties filters devices on whether their property attribute is a superset of the given JSON object value  - Distance from location filtering requires a latitude, longitude and distance (in meters). All devices within that range will be returned  - Bounding box requires a North,East,South and West point. All devices within that box will be returned.  The filters distance from location and bounding box are mutually exclusive. The location distance filter will take precedence.   # noqa: E501

        :param properties: Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped
        :type properties: str
        :param north: Used to filter devices within a bounding box
        :type north: float
        :param west: Used to filter devices within a bounding box
        :type west: float
        :param east: Used to filter devices within a bounding box
        :type east: float
        :param south: Used to filter devices within a bounding box
        :type south: float
        :param latitude: Used to filter devices within a distance from a point
        :type latitude: float
        :param longitude: Used to filter devices within a distance from a point
        :type longitude: float
        :param distance: Used to filter devices within a distance from a point.  The distance is given in meters. 
        :type distance: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :rtype: Generator[ListDevices200Response]
        """
        result = self.list_devices(properties=properties,north=north,west=west,east=east,south=south,latitude=latitude,longitude=longitude,distance=distance,cursor=cursor,limit=limit,)
        yield result
        while result.links.next != "":
            cursor = urllib.parse.parse_qs(urllib.parse.urlparse(result.links.next).query)['cursor'][0]
            result = self.list_devices(properties = properties,north = north,west = west,east = east,south = south,latitude = latitude,longitude = longitude,distance = distance,cursor = cursor,limit = limit,)
            yield result

    @validate_arguments
    def list_devices(self, properties : Annotated[Optional[StrictStr], Field(description="Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped")] = None, north : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, west : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, east : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, south : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, latitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, longitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, distance : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point.  The distance is given in meters. ")] = None, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ListDevices200Response:  # noqa: E501
        """List devices  # noqa: E501

        Fetch a list of devices.  Devices can be filtered on three items: properties, distance from a location or a bounding box.  - Filtering on properties filters devices on whether their property attribute is a superset of the given JSON object value  - Distance from location filtering requires a latitude, longitude and distance (in meters). All devices within that range will be returned  - Bounding box requires a North,East,South and West point. All devices within that box will be returned.  The filters distance from location and bounding box are mutually exclusive. The location distance filter will take precedence.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_devices(properties, north, west, east, south, latitude, longitude, distance, cursor, limit, async_req=True)
        >>> result = thread.get()

        :param properties: Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped
        :type properties: str
        :param north: Used to filter devices within a bounding box
        :type north: float
        :param west: Used to filter devices within a bounding box
        :type west: float
        :param east: Used to filter devices within a bounding box
        :type east: float
        :param south: Used to filter devices within a bounding box
        :type south: float
        :param latitude: Used to filter devices within a distance from a point
        :type latitude: float
        :param longitude: Used to filter devices within a distance from a point
        :type longitude: float
        :param distance: Used to filter devices within a distance from a point.  The distance is given in meters. 
        :type distance: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDevices200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_devices_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_devices_with_http_info(properties, north, west, east, south, latitude, longitude, distance, cursor, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def list_devices_with_http_info(self, properties : Annotated[Optional[StrictStr], Field(description="Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped")] = None, north : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, west : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, east : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, south : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a bounding box")] = None, latitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, longitude : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point")] = None, distance : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to filter devices within a distance from a point.  The distance is given in meters. ")] = None, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List devices  # noqa: E501

        Fetch a list of devices.  Devices can be filtered on three items: properties, distance from a location or a bounding box.  - Filtering on properties filters devices on whether their property attribute is a superset of the given JSON object value  - Distance from location filtering requires a latitude, longitude and distance (in meters). All devices within that range will be returned  - Bounding box requires a North,East,South and West point. All devices within that box will be returned.  The filters distance from location and bounding box are mutually exclusive. The location distance filter will take precedence.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_devices_with_http_info(properties, north, west, east, south, latitude, longitude, distance, cursor, limit, async_req=True)
        >>> result = thread.get()

        :param properties: Used to filter devices by its properties. This filters devices on whether their property contains the provided value. The value must be a JSON string and depending on your client should be URL Escaped
        :type properties: str
        :param north: Used to filter devices within a bounding box
        :type north: float
        :param west: Used to filter devices within a bounding box
        :type west: float
        :param east: Used to filter devices within a bounding box
        :type east: float
        :param south: Used to filter devices within a bounding box
        :type south: float
        :param latitude: Used to filter devices within a distance from a point
        :type latitude: float
        :param longitude: Used to filter devices within a distance from a point
        :type longitude: float
        :param distance: Used to filter devices within a distance from a point.  The distance is given in meters. 
        :type distance: float
        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDevices200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'properties',
            'north',
            'west',
            'east',
            'south',
            'latitude',
            'longitude',
            'distance',
            'cursor',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_devices" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('properties') is not None:  # noqa: E501
            _query_params.append(('properties', _params['properties']))

        if _params.get('north') is not None:  # noqa: E501
            _query_params.append(('north', _params['north']))

        if _params.get('west') is not None:  # noqa: E501
            _query_params.append(('west', _params['west']))

        if _params.get('east') is not None:  # noqa: E501
            _query_params.append(('east', _params['east']))

        if _params.get('south') is not None:  # noqa: E501
            _query_params.append(('south', _params['south']))

        if _params.get('latitude') is not None:  # noqa: E501
            _query_params.append(('latitude', _params['latitude']))

        if _params.get('longitude') is not None:  # noqa: E501
            _query_params.append(('longitude', _params['longitude']))

        if _params.get('distance') is not None:  # noqa: E501
            _query_params.append(('distance', _params['distance']))

        if _params.get('cursor') is not None:  # noqa: E501
            _query_params.append(('cursor', _params['cursor']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDevices200Response",
            '401': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/devices', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    
    @validate_arguments
    def list_sensors_gen(self, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> Generator[ListDeviceSensors200Response, None, None]:  # noqa: E501
        """List sensors  # noqa: E501
        This method wraps the API pagination logic and returns an generator which at each iteration fetches a new page.

        List all sensors.   # noqa: E501

        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :rtype: Generator[ListDeviceSensors200Response]
        """
        result = self.list_sensors(cursor=cursor,limit=limit,)
        yield result
        while result.links.next != "":
            cursor = urllib.parse.parse_qs(urllib.parse.urlparse(result.links.next).query)['cursor'][0]
            result = self.list_sensors(cursor = cursor,limit = limit,)
            yield result

    @validate_arguments
    def list_sensors(self, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ListDeviceSensors200Response:  # noqa: E501
        """List sensors  # noqa: E501

        List all sensors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_sensors(cursor, limit, async_req=True)
        >>> result = thread.get()

        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListDeviceSensors200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the list_sensors_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.list_sensors_with_http_info(cursor, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def list_sensors_with_http_info(self, cursor : Annotated[Optional[StrictStr], Field(description="The cursor for the current page")] = None, limit : Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. ")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List sensors  # noqa: E501

        List all sensors.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_sensors_with_http_info(cursor, limit, async_req=True)
        >>> result = thread.get()

        :param cursor: The cursor for the current page
        :type cursor: str
        :param limit: The maximum amount of items per page. Not applicable if `cursor` parameter is given. System limits are in place. 
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListDeviceSensors200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'cursor',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_sensors" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('cursor') is not None:  # noqa: E501
            _query_params.append(('cursor', _params['cursor']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "ListDeviceSensors200Response",
            '401': None,
            '403': None,
        }

        return self.api_client.call_api(
            '/sensors', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    

    @validate_arguments
    def update_device(self, id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The numeric ID of the device")], update_device_request : Optional[UpdateDeviceRequest] = None, **kwargs) -> UpdateDevice200Response:  # noqa: E501
        """Update device properties  # noqa: E501

        Update a some properties of the device with the given identifier.  The request body should contain one or more modifiable properties of the Device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_device(id, update_device_request, async_req=True)
        >>> result = thread.get()

        :param id: The numeric ID of the device (required)
        :type id: float
        :param update_device_request:
        :type update_device_request: UpdateDeviceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: UpdateDevice200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_device_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_device_with_http_info(id, update_device_request, **kwargs)  # noqa: E501

    @validate_arguments
    def update_device_with_http_info(self, id : Annotated[Union[StrictFloat, StrictInt], Field(..., description="The numeric ID of the device")], update_device_request : Optional[UpdateDeviceRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update device properties  # noqa: E501

        Update a some properties of the device with the given identifier.  The request body should contain one or more modifiable properties of the Device.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_device_with_http_info(id, update_device_request, async_req=True)
        >>> result = thread.get()

        :param id: The numeric ID of the device (required)
        :type id: float
        :param update_device_request:
        :type update_device_request: UpdateDeviceRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(UpdateDevice200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'update_device_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_device" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_device_request'] is not None:
            _body_params = _params['update_device_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['basicAuth']  # noqa: E501

        _response_types_map = {
            '200': "UpdateDevice200Response",
            '401': None,
            '403': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/devices/{id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
